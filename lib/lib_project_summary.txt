# lib

## Directory Structure

- lib/
  - gen.py
  - main.dart
  - models/
    - calculation_result.dart
    - practice_record.dart
  - screens/
    - machine_images_screen.dart
    - machine_parameters_screen.dart
    - monthly_summaries_tab.dart
    - records_screen.dart
    - slot_analyzer_screen.dart
  - services/
    - record_service.dart
    - slot_calculator.dart

## File Contents

### gen.py

```
import os
import fnmatch
import chardet

def is_binary(file_path):
    with open(file_path, 'rb') as file:
        return b'\0' in file.read(1024)

def read_file_contents(file_path):
    encodings = ['utf-8', 'shift_jis']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as file:
                print(f'Reading file: {file_path}')
                return file.read()
        except UnicodeDecodeError:
            pass
    return ''

def is_ignored(path, project_dir, gitignore_patterns, summaryignore_patterns, additional_ignore_patterns):
    relative_path = os.path.relpath(path, project_dir)
    for pattern in gitignore_patterns + summaryignore_patterns + additional_ignore_patterns:
        pattern = f"*{pattern}*"
        if fnmatch.fnmatch(relative_path, pattern) or fnmatch.fnmatch(f'{os.sep}{relative_path}', pattern):
            return True
    return False

def generate_project_summary(project_dir):
    project_name = os.path.basename(project_dir)
    summary = f'# {project_name}\n\n## Directory Structure\n\n'

    gitignore_patterns = read_gitignore(project_dir)
    print(f"gitignore_patterns: {gitignore_patterns}")
    summaryignore_patterns = read_summaryignore(project_dir)
    print(f"summaryignore_patterns: {summaryignore_patterns}")
    additional_ignore_patterns = ['generate_project_summary.py','.summaryignore', f'{project_name}_project_summary.txt', '.git']

    file_contents_section = "\n## File Contents\n\n"

    def traverse_directory(root, level):
        nonlocal summary, file_contents_section
        indent = '  ' * level
        relative_path = os.path.relpath(root, project_dir)
        if not is_ignored(relative_path, project_dir, gitignore_patterns, summaryignore_patterns, additional_ignore_patterns):
            summary += f'{indent}- {os.path.basename(root)}/\n'

            subindent = '  ' * (level + 1)
            for item in os.listdir(root):
                item_path = os.path.join(root, item)
                if os.path.isdir(item_path):
                    if not is_ignored(item_path, project_dir, gitignore_patterns, summaryignore_patterns, additional_ignore_patterns):
                        traverse_directory(item_path, level + 1)
                else:
                    if not is_ignored(item_path, project_dir, gitignore_patterns, summaryignore_patterns, additional_ignore_patterns):
                        if not is_binary(item_path):
                            summary += f'{subindent}- {item}\n'
                            content = read_file_contents(item_path)
                            if content.strip():
                                # ファイル名をプロジェクト名からの相対パスで表示
                                relative_file_path = os.path.relpath(item_path, project_dir)
                                file_contents_section += f'### {relative_file_path}\n\n```\n{content}\n```\n\n'
                        else:
                            summary += f'{subindent}- {item} (binary file)\n'

    traverse_directory(project_dir, 0)

    with open(f'{project_name}_project_summary.txt', 'w', encoding='utf-8') as file:
        file.write(summary + file_contents_section)

def read_gitignore(project_dir):
    gitignore_path = os.path.join(project_dir, '.gitignore')
    if os.path.exists(gitignore_path):
        with open(gitignore_path, 'r') as file:
            patterns = [line.strip() for line in file if line.strip() and not line.startswith('#')]
            expanded_patterns = []
            for pattern in patterns:
                expanded_patterns.append(pattern)
                if '/' in pattern:
                    expanded_patterns.append(pattern.replace('/', '\\'))
                if '\\' in pattern:
                    expanded_patterns.append(pattern.replace('\\', '/'))
            return expanded_patterns
    return []

def read_summaryignore(project_dir):
    summaryignore_path = os.path.join(project_dir, '.summaryignore')
    if os.path.exists(summaryignore_path):
        with open(summaryignore_path, 'r') as file:
            patterns = [line.strip() for line in file if line.strip() and not line.startswith('#')]
            expanded_patterns = []
            for pattern in patterns:
                expanded_patterns.append(pattern)
                if '/' in pattern:
                    expanded_patterns.append(pattern.replace('/', '\\'))
                if '\\' in pattern:
                    expanded_patterns.append(pattern.replace('\\', '/'))
            return expanded_patterns
    return []

if __name__ == '__main__':
    project_directory = input('Enter the project directory path (leave blank for current directory): ')
    if not project_directory:
        project_directory = os.getcwd()
    generate_project_summary(project_directory)

```

### main.dart

```
// lib/main.dart

import 'package:flutter/material.dart';
import 'screens/slot_analyzer_screen.dart';

void main() {
  runApp(SlotAnalyzerApp());
}

class SlotAnalyzerApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: '設定判別ツール',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity,
      ),
      home: SlotAnalyzerScreen(),
    );
  }
}
```

### models\calculation_result.dart

```
// lib/models/calculation_result.dart

class CalculationResult {
  final List<double> probabilities;
  final double averageSettings;
  final double averagePayout;
  final double averageWage;
  final List<String> probStrings;

  CalculationResult({
    required this.probabilities,
    required this.averageSettings,
    required this.averagePayout,
    required this.averageWage,
    required this.probStrings,
  });
}
```

### models\practice_record.dart

```
import '../services/slot_calculator.dart';

class PracticeRecord {
  final DateTime date;
  final SlotMachine machine;
  final int gameCount;
  final double bigProbability;
  final double regProbability;
  final double budouProbability;
  final int budouCount;
  final int? coinDifference;  // 追加: 差枚数（nullable）

  PracticeRecord({
    required this.date,
    required this.machine,
    required this.gameCount,
    required this.bigProbability,
    required this.regProbability,
    required this.budouProbability,
    required this.budouCount,
    this.coinDifference,  // 追加
  });

  // コピーと更新のためのメソッドを追加
  PracticeRecord copyWith({
    DateTime? date,
    SlotMachine? machine,
    int? gameCount,
    double? bigProbability,
    double? regProbability,
    double? budouProbability,
    int? budouCount,
    int? coinDifference,
  }) {
    return PracticeRecord(
      date: date ?? this.date,
      machine: machine ?? this.machine,
      gameCount: gameCount ?? this.gameCount,
      bigProbability: bigProbability ?? this.bigProbability,
      regProbability: regProbability ?? this.regProbability,
      budouProbability: budouProbability ?? this.budouProbability,
      budouCount: budouCount ?? this.budouCount,
      coinDifference: coinDifference ?? this.coinDifference,
    );
  }

  // 数値またはInfinityを安全にパースするヘルパーメソッド
  static double _parseDoubleOrInfinity(dynamic value) {
    if (value == null || value == 'Infinity') {
      return double.infinity;
    }
    if (value is num) {
      return value.toDouble();
    }
    try {
      return double.parse(value.toString());
    } catch (e) {
      return double.infinity;
    }
  }

  factory PracticeRecord.fromJson(Map<String, dynamic> json) {
    return PracticeRecord(
      date: DateTime.parse(json['date']),
      machine: SlotMachine.values.firstWhere(
            (e) => e.toString() == json['machine'],
      ),
      gameCount: json['gameCount'],
      bigProbability: _parseDoubleOrInfinity(json['bigProbability']),
      regProbability: _parseDoubleOrInfinity(json['regProbability']),
      budouProbability: _parseDoubleOrInfinity(json['budouProbability'] ?? 'Infinity'),
      budouCount: json['budouCount'] ?? 0,
      coinDifference: json['coinDifference'],  // 追加
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'date': date.toIso8601String(),
      'machine': machine.toString(),
      'gameCount': gameCount,
      'bigProbability': bigProbability.isInfinite ? 'Infinity' : bigProbability,
      'regProbability': regProbability.isInfinite ? 'Infinity' : regProbability,
      'budouProbability': budouProbability.isInfinite ? 'Infinity' : budouProbability,
      'budouCount': budouCount,
      'coinDifference': coinDifference,  // 追加
    };
  }
}
```

### screens\machine_images_screen.dart

```
import 'package:flutter/material.dart';

class MachineImagesScreen extends StatelessWidget {
  final List<MachineImage> machineImages = [
    MachineImage(
      name: 'アイムジャグラーEX',
      path: 'assets/img/im_juggler.gif',
    ),
    MachineImage(
      name: 'マイジャグラーⅤ',
      path: 'assets/img/my_juggler.gif',
    ),
    MachineImage(
      name: 'ゴーゴージャグラー3',
      path: 'assets/img/gogo_juggler.png',
    ),
    MachineImage(
      name: 'ファンキージャグラー2',
      path: 'assets/img/funky_juggler.png',
    ),
    MachineImage(
      name: 'ハッピージャグラーV Ⅲ',
      path: 'assets/img/happy_juggler.gif',
    ),
    MachineImage(
      name: 'ジャグラーガールズSS',
      path: 'assets/img/juggler_girls.jpg',
    ),
    MachineImage(
      name: 'ミスタージャグラー',
      path: 'assets/img/mister_juggler.jpg',
    ),
    MachineImage(
      name: 'ウルトラミラクルジャグラー',
      path: 'assets/img/ultramiracle_juggler.jpg',
    ),
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('機種画像一覧'),
      ),
      body: GridView.builder(
        padding: EdgeInsets.all(8),
        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: MediaQuery.of(context).size.width > 600 ? 1 : 2,
          childAspectRatio: 1.0,
          crossAxisSpacing: 8,
          mainAxisSpacing: 8,
        ),
        itemCount: machineImages.length,
        itemBuilder: (context, index) {
          final machineImage = machineImages[index];

          return Card(
            elevation: 4,
            child: Column(
              children: [
                Padding(
                  padding: EdgeInsets.all(8.0),
                  child: Text(
                    machineImage.name,
                    style: TextStyle(fontSize: 14),
                    textAlign: TextAlign.center,
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                Expanded(
                  child: Padding(
                    padding: EdgeInsets.all(8.0),
                    child: GestureDetector(
                      onTap: () {
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                            builder: (context) => ImageDetailScreen(
                              machineImage: machineImage,
                            ),
                          ),
                        );
                      },
                      child: Image.asset(
                        machineImage.path,
                        fit: BoxFit.contain,
                        errorBuilder: (context, error, stackTrace) {
                          print('Error loading image: ${machineImage.path}');
                          print('Error details: $error');
                          return Center(
                            child: Column(
                              mainAxisAlignment: MainAxisAlignment.center,
                              children: [
                                Icon(Icons.error, color: Colors.red),
                                SizedBox(height: 8),
                                Text(
                                  '画像を読み込めません',
                                  style: TextStyle(color: Colors.red),
                                  textAlign: TextAlign.center,
                                ),
                              ],
                            ),
                          );
                        },
                      ),
                    ),
                  ),
                ),
              ],
            ),
          );
        },
      ),
    );
  }
}

class ImageDetailScreen extends StatelessWidget {
  final MachineImage machineImage;

  const ImageDetailScreen({
    Key? key,
    required this.machineImage,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(machineImage.name),
      ),
      body: Center(
        child: InteractiveViewer(
          minScale: 0.5,
          maxScale: 4.0,
          child: Image.asset(
            machineImage.path,
            fit: BoxFit.contain,
          ),
        ),
      ),
    );
  }
}

class MachineImage {
  final String name;
  final String path;

  MachineImage({
    required this.name,
    required this.path,
  });
}
```

### screens\machine_parameters_screen.dart

```
// lib/screens/machine_parameters_screen.dart

import 'package:flutter/material.dart';
import '../services/slot_calculator.dart';

class MachineParametersScreen extends StatelessWidget {
  final SlotMachine machine;
  final Map<String, String>? currentProbabilities;

  const MachineParametersScreen({
    Key? key,
    required this.machine,
    this.currentProbabilities,
  }) : super(key: key);

  List<int> _findClosestValueIndices(String currentProb, List<double> values) {
    if (currentProb.isEmpty || currentProb == "－") return [];

    try {
      final parts = currentProb.split('/');
      if (parts.length != 2) return [];

      double targetProb = 1.0 / double.parse(parts[1]);
      double minDiff = double.infinity;
      List<int> closestIndices = [];

      // まず最小の差分を見つける
      for (int i = 0; i < values.length; i++) {
        double diff = (1.0 / values[i] - targetProb).abs();
        if (diff < minDiff) {
          minDiff = diff;
        }
      }

      // 最小の差分と同じ差分を持つインデックスを全て収集
      for (int i = 0; i < values.length; i++) {
        double diff = (1.0 / values[i] - targetProb).abs();
        if ((diff - minDiff).abs() < 1e-10) { // 浮動小数点の誤差を考慮
          closestIndices.add(i);
        }
      }

      return closestIndices;
    } catch (e) {
      return [];
    }
  }

  @override
  Widget build(BuildContext context) {
    final params = SlotCalculator.machineParameters[machine]!;
    final machineName = _getMachineName(machine);

    final probMap = {
      'single_big': currentProbabilities?['single_big'] ?? '',
      'single_reg': currentProbabilities?['single_reg'] ?? '',
      'cherry_big': currentProbabilities?['cherry_big'] ?? '',
      'cherry_reg': currentProbabilities?['cherry_reg'] ?? '',
      'budou': currentProbabilities?['budou'] ?? '',
      'single_cherry': currentProbabilities?['single_cherry'] ?? '',
      'big_sum': currentProbabilities?['big_sum'] ?? '',
      'reg_sum': currentProbabilities?['reg_sum'] ?? '',
    };

    return Scaffold(
      appBar: AppBar(
        title: Text('$machineName パラメータ'),
      ),
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildParameterTable('設定別機械割', params['payout']!),
              SizedBox(height: 16),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    child: _buildParameterTable(
                      '単独BIG確率',
                      params['single_big']!,
                      currentProb: probMap['single_big'],
                    ),
                  ),
                  SizedBox(width: 16),
                  Expanded(
                    child: _buildParameterTable(
                      '単独REG確率',
                      params['single_reg']!,
                      currentProb: probMap['single_reg'],
                    ),
                  ),
                ],
              ),
              SizedBox(height: 16),
              if (machine != SlotMachine.gogoJuggler &&
                  machine != SlotMachine.jugglerGirls &&
                  machine != SlotMachine.misterJuggler) ...[
                Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Expanded(
                      child: _buildParameterTable(
                        '角チェリー + BIG確率',
                        params['cherry_big']!,
                        currentProb: probMap['cherry_big'],
                      ),
                    ),
                    SizedBox(width: 16),
                    Expanded(
                      child: _buildParameterTable(
                        '角チェリー + REG確率',
                        params['cherry_reg']!,
                        currentProb: probMap['cherry_reg'],
                      ),
                    ),
                  ],
                ),
                SizedBox(height: 16),
              ],
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    child: _buildParameterTable(
                      'ぶどう確率',
                      params['budou']!,
                      currentProb: probMap['budou'],
                    ),
                  ),
                  SizedBox(width: 16),
                  Expanded(
                    child: _buildParameterTable(
                      '単独チェリー確率',
                      params['single_cherry']!,
                      currentProb: probMap['single_cherry'],
                    ),
                  ),
                ],
              ),
              SizedBox(height: 16),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Expanded(
                    child: _buildParameterTable(
                      'BIG合算確率',
                      params['big_sum']!,
                      currentProb: probMap['big_sum'],
                    ),
                  ),
                  SizedBox(width: 16),
                  Expanded(
                    child: _buildParameterTable(
                      'REG合算確率',
                      params['reg_sum']!,
                      currentProb: probMap['reg_sum'],
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildParameterTable(String title, List<double> values, {String? currentProb}) {
    final closestIndices = currentProb != null ? _findClosestValueIndices(currentProb, values) : <int>[];

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              title,
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            SizedBox(height: 8),
            if (currentProb != null && currentProb != "－")
              Text(
                '現在: $currentProb',
                style: TextStyle(
                  fontSize: 16,
                  color: Colors.blue,
                ),
              ),
            SizedBox(height: 8),
            Table(
              border: TableBorder.all(),
              columnWidths: const <int, TableColumnWidth>{
                0: FlexColumnWidth(1),
                1: FlexColumnWidth(2),
              },
              children: [
                TableRow(
                  decoration: BoxDecoration(color: Colors.grey[200]),
                  children: [
                    _buildTableCell('設定', header: true),
                    _buildTableCell('値', header: true),
                  ],
                ),
                ...List.generate(6, (index) => TableRow(
                  decoration: BoxDecoration(
                    color: closestIndices.contains(index) ? Colors.yellow[100] : null,
                  ),
                  children: [
                    _buildTableCell('${index + 1}'),
                    _buildTableCell(values[index].toString()),
                  ],
                )),
              ],
            ),
          ],
        ),
      ),
    );
  }
  Widget _buildTableCell(String text, {bool header = false}) {
    return Container(
      padding: EdgeInsets.all(1),
      child: Text(
        text,
        textAlign: TextAlign.center,
        style: TextStyle(
          fontWeight: header ? FontWeight.bold : FontWeight.normal,
        ),
      ),
    );
  }

  String _getMachineName(SlotMachine machine) {
    switch (machine) {
      case SlotMachine.imJuggler:
        return 'アイムジャグラーEX';
      case SlotMachine.myJuggler:
        return 'マイジャグラーⅤ';
      case SlotMachine.gogoJuggler:
        return 'ゴーゴージャグラー3';
      case SlotMachine.funkyJuggler:
        return 'ファンキージャグラー2';
      case SlotMachine.happyJuggler:
        return 'ハッピージャグラーV Ⅲ';
      case SlotMachine.jugglerGirls:
        return 'ジャグラーガールズSS';
      case SlotMachine.misterJuggler:
        return 'ミスタージャグラー';
      case SlotMachine.ultramiracleJuggler:
        return 'ウルトラミラクルジャグラー';
      case SlotMachine.newPulserBT:
        return 'ニューパルサーBT';
      default:
        return machine.toString();
    }
  }
}
```

### screens\monthly_summaries_tab.dart

```
// lib/screens/monthly_summaries_tab.dart

import 'package:flutter/material.dart';
import '../models/practice_record.dart';
import '../services/record_service.dart';

class MonthlySummariesTab extends StatelessWidget {
  final List<PracticeRecord> records;

  const MonthlySummariesTab({Key? key, required this.records}) : super(key: key);

  Map<String, Map<String, dynamic>> _calculateMonthlySummaries() {
    Map<String, Map<String, dynamic>> summaries = {};

    for (var record in records) {
      String monthKey = '${record.date.year}/${record.date.month.toString().padLeft(2, '0')}';

      if (!summaries.containsKey(monthKey)) {
        summaries[monthKey] = {
          'totalGames': 0,
          'totalBigCount': 0,
          'totalRegCount': 0,
          'totalBudouCount': 0,
          'totalCoinDifference': 0,
        };
      }

      var summary = summaries[monthKey]!;
      summary['totalGames'] += record.gameCount;

      if (!record.bigProbability.isInfinite && !record.bigProbability.isNaN) {
        summary['totalBigCount'] += (record.gameCount / record.bigProbability).round();
      }

      if (!record.regProbability.isInfinite && !record.regProbability.isNaN) {
        summary['totalRegCount'] += (record.gameCount / record.regProbability).round();
      }

      summary['totalBudouCount'] += record.budouCount;

      if (record.coinDifference != null) {
        summary['totalCoinDifference'] += record.coinDifference!;
      }
    }

    // 確率と機械割の計算
    summaries.forEach((month, data) {
      if (data['totalGames'] > 0) {
        // BIG確率
        if (data['totalBigCount'] > 0) {
          data['avgBigProbability'] = data['totalGames'] / data['totalBigCount'];
        } else {
          data['avgBigProbability'] = double.infinity;
        }

        // REG確率
        if (data['totalRegCount'] > 0) {
          data['avgRegProbability'] = data['totalGames'] / data['totalRegCount'];
        } else {
          data['avgRegProbability'] = double.infinity;
        }

        // ぶどう確率
        if (data['totalBudouCount'] > 0) {
          data['avgBudouProbability'] = data['totalGames'] / data['totalBudouCount'];
        } else {
          data['avgBudouProbability'] = double.infinity;
        }

        // 機械割の計算
        double machineEfficiency = 100.0;
        if (data['totalGames'] > 0) {
          machineEfficiency = ((data['totalGames'] * 3 + data['totalCoinDifference']) / (data['totalGames'] * 3)) * 100;
        }
        data['machineEfficiency'] = machineEfficiency;
      }
    });

    return Map.fromEntries(
        summaries.entries.toList()
          ..sort((a, b) => b.key.compareTo(a.key))
    );
  }

  @override
  Widget build(BuildContext context) {
    final monthlySummaries = _calculateMonthlySummaries();

    if (monthlySummaries.isEmpty) {
      return Center(
        child: Text('記録がありません'),
      );
    }

    return ListView.builder(
      itemCount: monthlySummaries.length,
      itemBuilder: (context, index) {
        final month = monthlySummaries.keys.elementAt(index);
        final summary = monthlySummaries[month]!;

        return Card(
          margin: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          child: Padding(
            padding: EdgeInsets.all(12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  month,
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                SizedBox(height: 8),
                Text('総実践G数: ${summary['totalGames']}G'),
                Row(
                  children: [
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text('総BIG回数: ${summary['totalBigCount']}回'),
                          Text(
                            'BIG確率: ${RecordService.getProbabilityFraction(summary['avgBigProbability'] ?? double.infinity)}',
                          ),
                        ],
                      ),
                    ),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text('総REG回数: ${summary['totalRegCount']}回'),
                          Text(
                            'REG確率: ${RecordService.getProbabilityFraction(summary['avgRegProbability'] ?? double.infinity)}',
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
                Divider(),
                Text('ぶどう'),
                Text(
                  '総回数: ${summary['totalBudouCount']}回\n'
                      '確率: ${RecordService.getProbabilityFraction(summary['avgBudouProbability'] ?? double.infinity)}',
                ),
                if (summary['totalCoinDifference'] != 0) ...[
                  Divider(),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        '総差枚数: ${summary['totalCoinDifference']}枚',
                        style: TextStyle(
                          color: summary['totalCoinDifference'] >= 0 ? Colors.blue : Colors.red,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Text(
                        '機械割: ${summary['machineEfficiency'].toStringAsFixed(2)}%',
                        style: TextStyle(
                          color: summary['machineEfficiency'] >= 100 ? Colors.blue : Colors.red,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ],
                  ),
                ],
              ],
            ),
          ),
        );
      },
    );
  }
}
```

### screens\records_screen.dart

```
// lib/screens/records_screen.dart

import 'package:flutter/material.dart';
import '../models/practice_record.dart';
import '../services/record_service.dart';
import '../services/slot_calculator.dart';
import 'monthly_summaries_tab.dart';

class RecordsScreen extends StatefulWidget {
  @override
  _RecordsScreenState createState() => _RecordsScreenState();
}

class _RecordsScreenState extends State<RecordsScreen> {
  List<PracticeRecord> _records = [];
  Map<SlotMachine, Map<String, dynamic>> _summaries = {};
  Set<PracticeRecord> _selectedRecords = {};
  bool _isSelectionMode = false;

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  Future<void> _loadData() async {
    try {
      final records = await RecordService.getAllRecords();
      final summaries = await RecordService.getMachineSummaries();
      if (mounted) {
        setState(() {
          _records = records..sort((a, b) => b.date.compareTo(a.date));
          _summaries = summaries;
        });
      }
    } catch (e) {
      print('Error loading data: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('データの読み込み中にエラーが発生しました'),
            duration: Duration(seconds: 3),
          ),
        );
      }
    }
  }

  Future<void> _showCoinDifferenceDialog(PracticeRecord record) async {
    final controller = TextEditingController(
      text: record.coinDifference?.toString() ?? '',
    );

    return showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('差枚数の入力'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '${_formatDate(record.date)}\n'
                  '${_getMachineName(record.machine)}\n'
                  '実践G数: ${record.gameCount}G',
              style: TextStyle(fontSize: 14),
            ),
            SizedBox(height: 16),
            TextField(
              controller: controller,
              keyboardType: TextInputType.numberWithOptions(signed: true),
              decoration: InputDecoration(
                labelText: '差枚数',
                suffix: Text('枚'),
                border: OutlineInputBorder(),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('キャンセル'),
          ),
          TextButton(
            onPressed: () async {
              final value = int.tryParse(controller.text);
              if (value != null) {
                await RecordService.updateCoinDifference(
                  record.date,
                  record.machine,
                  value,
                );
                Navigator.pop(context);
                _loadData();  // データを再読み込み
              }
            },
            child: Text('保存'),
          ),
        ],
      ),
    );
  }

  String _getMachineName(SlotMachine machine) {
    switch (machine) {
      case SlotMachine.imJuggler:
        return 'アイムジャグラーEX';
      case SlotMachine.myJuggler:
        return 'マイジャグラーⅤ';
      case SlotMachine.gogoJuggler:
        return 'ゴーゴージャグラー3';
      case SlotMachine.funkyJuggler:
        return 'ファンキージャグラー2';
      case SlotMachine.happyJuggler:
        return 'ハッピージャグラーV Ⅲ';
      case SlotMachine.jugglerGirls:
        return 'ジャグラーガールズSS';
      case SlotMachine.misterJuggler:
        return 'ミスタージャグラー';
      case SlotMachine.ultramiracleJuggler:
        return 'ウルトラミラクルジャグラー';
      case SlotMachine.newPulserBT:
        return 'ニューパルサーBT';
      default:
        return machine.toString();
    }
  }

  String _formatDate(DateTime date) {
    return '${date.year}/${date.month.toString().padLeft(2, '0')}/${date.day.toString().padLeft(2, '0')}';
  }

  Future<void> _deleteSelectedRecords() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('削除の確認'),
        content: Text('選択した${_selectedRecords.length}件の記録を削除しますか？'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text('キャンセル'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: Text(
              '削除',
              style: TextStyle(color: Colors.red),
            ),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await RecordService.deleteRecords(_selectedRecords.toList());
      await _loadData();
      setState(() {
        _selectedRecords.clear();
        _isSelectionMode = false;
      });
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('選択した記録を削除しました')),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 3,
      child: Scaffold(
        appBar: AppBar(
          title: Text('実践記録'),
          actions: [
            if (_records.isNotEmpty) ...[
              if (_isSelectionMode) ...[
                TextButton(
                  onPressed: () {
                    setState(() {
                      if (_selectedRecords.length == _records.length) {
                        _selectedRecords.clear();
                      } else {
                        _selectedRecords = Set.from(_records);
                      }
                    });
                  },
                  child: Text(
                    _selectedRecords.length == _records.length ? '全解除' : '全選択',
                    style: TextStyle(color: Colors.white),
                  ),
                ),
                IconButton(
                  icon: Icon(Icons.delete),
                  onPressed: _selectedRecords.isEmpty ? null : _deleteSelectedRecords,
                ),
              ],
              IconButton(
                icon: Icon(_isSelectionMode ? Icons.close : Icons.select_all),
                onPressed: () {
                  setState(() {
                    _isSelectionMode = !_isSelectionMode;
                    if (!_isSelectionMode) {
                      _selectedRecords.clear();
                    }
                  });
                },
              ),
            ],
          ],
          bottom: TabBar(
            tabs: [
              Tab(text: '記録一覧'),
              Tab(text: '機種別集計'),
              Tab(text: '月別集計'),
            ],
          ),
        ),
        body: TabBarView(
          children: [
            _buildRecordsList(),
            _buildMachineSummaries(),
            MonthlySummariesTab(records: _records),
          ],
        ),
      ),
    );
  }

  Widget _buildRecordsList() {
    if (_records.isEmpty) {
      return Center(
        child: Text('記録がありません'),
      );
    }

    return ListView.builder(
      itemCount: _records.length,
      itemBuilder: (context, index) {
        final record = _records[index];
        final isSelected = _selectedRecords.contains(record);

        return Card(
          margin: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          child: InkWell(
            onTap: _isSelectionMode
                ? () {
              setState(() {
                if (isSelected) {
                  _selectedRecords.remove(record);
                } else {
                  _selectedRecords.add(record);
                }
              });
            }
                : () => _showCoinDifferenceDialog(record),
            onLongPress: !_isSelectionMode
                ? () {
              setState(() {
                _isSelectionMode = true;
                _selectedRecords.add(record);
              });
            }
                : null,
            child: Container(
              color: isSelected ? Colors.blue.withOpacity(0.1) : null,
              child: Padding(
                padding: EdgeInsets.all(12),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Expanded(
                          child: Text(
                            _getMachineName(record.machine),
                            style: TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                        Text(
                          _formatDate(record.date),
                          style: TextStyle(color: Colors.grey[600]),
                        ),
                      ],
                    ),
                    SizedBox(height: 8),
                    Text('実践G数: ${record.gameCount}G'),
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            'BIG確率: ${RecordService.getProbabilityFraction(record.bigProbability)}',
                          ),
                        ),
                        Expanded(
                          child: Text(
                            'REG確率: ${RecordService.getProbabilityFraction(record.regProbability)}',
                          ),
                        ),
                      ],
                    ),
                    Text(
                      'ぶどう確率: ${RecordService.getProbabilityFraction(record.budouProbability)} (${record.budouCount}回)',
                    ),
                    if (record.coinDifference != null) ...[
                      SizedBox(height: 4),
                      Text(
                        '差枚数: ${record.coinDifference}枚',
                        style: TextStyle(
                          color: record.coinDifference! >= 0
                              ? Colors.blue
                              : Colors.red,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildMachineSummaries() {
    if (_summaries.isEmpty) {
      return Center(
        child: Text('記録がありません'),
      );
    }

    return ListView.builder(
      itemCount: _summaries.length,
      itemBuilder: (context, index) {
        final machine = _summaries.keys.elementAt(index);
        final summary = _summaries[machine]!;
        final totalCoinDifference = summary['totalCoinDifference'] ?? 0;
        final totalGames = summary['totalGames'];

        // 機械割の計算
        double machineEfficiency = 100.0; // デフォルト値
        if (totalGames > 0) {
          machineEfficiency = ((totalGames * 3 + totalCoinDifference) / (totalGames * 3)) * 100;
        }

        return Card(
          margin: EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          child: Padding(
            padding: EdgeInsets.all(12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  _getMachineName(machine),
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                SizedBox(height: 8),
                Text('総実践G数: ${summary['totalGames']}G'),
                Row(
                  children: [
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text('総BIG回数: ${summary['totalBigCount']}回'),
                          Text(
                            'BIG確率: ${RecordService.getProbabilityFraction(summary['avgBigProbability'] ?? double.infinity)}',
                          ),
                        ],
                      ),
                    ),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text('総REG回数: ${summary['totalRegCount']}回'),
                          Text(
                            'REG確率: ${RecordService.getProbabilityFraction(summary['avgRegProbability'] ?? double.infinity)}',
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
                Divider(),
                Text('ぶどう'),
                Text(
                  '総回数: ${summary['totalBudouCount']}回\n'
                      '確率: ${RecordService.getProbabilityFraction(summary['avgBudouProbability'] ?? double.infinity)}',
                ),
                if (totalCoinDifference != 0) ...[
                  Divider(),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        '総差枚数: ${totalCoinDifference}枚',
                        style: TextStyle(
                          color: totalCoinDifference >= 0 ? Colors.blue : Colors.red,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      Text(
                        '機械割: ${machineEfficiency.toStringAsFixed(2)}%',
                        style: TextStyle(
                          color: machineEfficiency >= 100 ? Colors.blue : Colors.red,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ],
                  ),
                ],
              ],
            ),
          ),
        );
      },
    );
  }
}
```

### screens\slot_analyzer_screen.dart

```
// lib/screens/slot_analyzer_screen.dart

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:fluttertoast/fluttertoast.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:slot_calc/screens/records_screen.dart';
import '../../models/calculation_result.dart';
import '../../services/slot_calculator.dart';
import '../models/practice_record.dart';
import '../services/record_service.dart';
import 'machine_parameters_screen.dart';
import 'machine_images_screen.dart';

class SlotAnalyzerScreen extends StatefulWidget {
  @override
  _SlotAnalyzerScreenState createState() => _SlotAnalyzerScreenState();
}

class _SlotAnalyzerScreenState extends State<SlotAnalyzerScreen>  with WidgetsBindingObserver{
  // 機種選択の状態を保存するキー
  static const String _selectedMachineKey = 'selectedMachine';

  SlotMachine selectedMachine = SlotMachine.imJuggler;
  final _formKey = GlobalKey<FormState>();
  final _scrollController = ScrollController(); // ScrollController追加
  bool _showHaibun = false;

  // TextEditingController群
  final total1Controller = TextEditingController();
  final countAController = TextEditingController();
  final countBController = TextEditingController();
  final countCController = TextEditingController();
  final countDController = TextEditingController();
  final countEController = TextEditingController();
  final countHController = TextEditingController();
  final total2Controller = TextEditingController();
  final countFController = TextEditingController();
  final countGController = TextEditingController();

  final List<TextEditingController> haibunControllers =
  List.generate(6, (index) => TextEditingController());

  final FocusScopeNode _focusScopeNode = FocusScopeNode();

  // 計算結果
  CalculationResult? result;

  // 分数表示用の値を保持する変数
  String _total1Fraction = '';
  String _total2Fraction = '';
  Timer? _debounceTimer;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _loadSavedData();

    // デバウンス処理を入れたリスナーの設定
    void updateFractions() {
      if (_debounceTimer?.isActive ?? false) _debounceTimer!.cancel();
      _debounceTimer = Timer(Duration(milliseconds: 300), () {
        if (!mounted) return;
        setState(() {
          // 必要な分数のみを更新
          _updateFractions();
        });
      });
    }

    // 必要最小限のコントローラーにのみリスナーを追加
    total1Controller.addListener(updateFractions);
    countFController.addListener(updateFractions);
    countGController.addListener(updateFractions);
    total2Controller.addListener(updateFractions);
  }

  // 分数計算を効率化
  void _updateFractions() {
    final total1 = int.tryParse(total1Controller.text) ?? 0;
    final total2 = int.tryParse(total2Controller.text) ?? 0;

    if (total1 > 0) {
      _total1Fraction = (total1 - total2).toString();
    } else {
      _total1Fraction = '';
    }

    if (total2 > 0) {
      _total2Fraction = total2.toString();
    } else {
      _total2Fraction = '';
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _saveData();
    _debounceTimer?.cancel();
    _scrollController.dispose();
    _focusScopeNode.dispose();
    // コントローラーの破棄
    total1Controller.dispose();
    countAController.dispose();
    countBController.dispose();
    countCController.dispose();
    countDController.dispose();
    countEController.dispose();
    countHController.dispose();
    total2Controller.dispose();
    countFController.dispose();
    countGController.dispose();
    for (var controller in haibunControllers) {
      controller.dispose();
    }
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.paused || state == AppLifecycleState.inactive) {
      _saveData();
    } else if (state == AppLifecycleState.resumed) {
      // アプリがレジュームされたときの処理を追加
      setState(() {
        _focusScopeNode.unfocus();
        Future.delayed(Duration(milliseconds: 100), () {
          if (mounted) {
            _focusScopeNode.requestFocus();
          }
        });
      });
    }
  }

  // データの保存
  Future<void> _saveData() async {
    final prefs = await SharedPreferences.getInstance();

    // 機種選択の保存
    await prefs.setInt(_selectedMachineKey, selectedMachine.index);

    // データカウンター部分の保存
    await prefs.setString('total2', total2Controller.text);
    await prefs.setString('countF', countFController.text);
    await prefs.setString('countG', countGController.text);

    // ボーナス・小役確率部分の保存
    await prefs.setString('total1', total1Controller.text);
    await prefs.setString('countA', countAController.text);
    await prefs.setString('countB', countBController.text);
    await prefs.setString('countC', countCController.text);
    await prefs.setString('countD', countDController.text);
    await prefs.setString('countE', countEController.text);
    await prefs.setString('countH', countHController.text);

    // 設定配分の保存
    for (int i = 0; i < haibunControllers.length; i++) {
      await prefs.setString('haibun$i', haibunControllers[i].text);
    }

    // 表示状態の保存
    await prefs.setBool('showHaibun', _showHaibun);
  }

  // 保存したデータの読み込み
  Future<void> _loadSavedData() async {
    final prefs = await SharedPreferences.getInstance();

    setState(() {
      // 機種選択の読み込み
      final savedMachineIndex = prefs.getInt(_selectedMachineKey);
      if (savedMachineIndex != null && savedMachineIndex < SlotMachine.values.length) {
        selectedMachine = SlotMachine.values[savedMachineIndex];
      }

      // データカウンター部分の読み込み
      total2Controller.text = prefs.getString('total2') ?? '';
      countFController.text = prefs.getString('countF') ?? '';
      countGController.text = prefs.getString('countG') ?? '';

      // ボーナス・小役確率部分の読み込み
      total1Controller.text = prefs.getString('total1') ?? '';
      countAController.text = prefs.getString('countA') ?? '';
      countBController.text = prefs.getString('countB') ?? '';
      countCController.text = prefs.getString('countC') ?? '';
      countDController.text = prefs.getString('countD') ?? '';
      countEController.text = prefs.getString('countE') ?? '';
      countHController.text = prefs.getString('countH') ?? '';

      // 設定配分の読み込み
      for (int i = 0; i < haibunControllers.length; i++) {
        haibunControllers[i].text = prefs.getString('haibun$i') ?? '';
      }

      // 表示状態の読み込み
      _showHaibun = prefs.getBool('showHaibun') ?? false;
    });

    // フラクション表示の更新
    _updateFractions();
  }

  // ボーナス・小役確率フォームのクリア
  void _clearBonusForm() {
    setState(() {
      total1Controller.clear();
      countAController.clear();
      countBController.clear();
      countCController.clear();
      countDController.clear();
      countEController.clear();
      countHController.clear();
    });
    _saveData();
  }

  // データカウンターフォームのクリア
  void _clearCounterForm() {
    setState(() {
      total2Controller.clear();
      countFController.clear();
      countGController.clear();
    });
    _saveData();
  }

  void _calculate() {
    if (_formKey.currentState!.validate()) {
      setState(() {
        result = SlotCalculator.calculate(
          total1: total1Controller.text,
          countA: countAController.text,
          countB: countBController.text,
          countC: countCController.text,
          countD: countDController.text,
          countE: countEController.text,
          total2: total2Controller.text,
          countF: countFController.text,
          countG: countGController.text,
          countH: countHController.text,
          haibun: haibunControllers.map((c) => c.text).toList(),
          machine: selectedMachine,
        );
      });

      // 計算後、少し遅延させてスクロール
      Future.delayed(Duration(milliseconds: 100), () {
        _scrollController.animateTo(
          _scrollController.position.maxScrollExtent,
          duration: Duration(milliseconds: 200),
          curve: Curves.easeOut,
        );
      });
    }
  }

  // 確率文字列を計算する補助関数を追加
  String _calculateProbString(int total, int count) {
    if (total <= 0 || count <= 0) return "－";
    return "1/${(total/count).toStringAsFixed(3)}";
  }

  Widget _buildInputField(
      String label,
      TextEditingController controller,
      {String? suffix}
      ) {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 8.0),
      child: TextFormField(
        controller: controller,
        decoration: InputDecoration(
          labelText: label,
          suffix: suffix != null ? Text(suffix) : null,
          border: OutlineInputBorder(),
        ),
        keyboardType: TextInputType.number,
        validator: (value) {
          if (value == null || value.isEmpty) {
            return null;
          }
          if (int.tryParse(value) == null) {
            return '数値を入力してください';
          }
          return null;
        },
      ),
    );
  }

  // 分数を計算して文字列で返す関数
  String _calculateFraction(String count, String total) {
    if (count.isEmpty || total.isEmpty) return '';
    final countNum = int.tryParse(count);
    final totalNum = int.tryParse(total);
    if (countNum == null || totalNum == null || totalNum == 0 || countNum == 0) return '';

    return '1/${(totalNum / countNum).toStringAsFixed(2)}';
  }

  void _saveRecord() async {
    final gameCount = (int.tryParse(total1Controller.text) ?? 0) -
        (int.tryParse(total2Controller.text) ?? 0);

    if (gameCount <= 0) {
      Fluttertoast.showToast(msg: "有効なゲーム数を入力してください");
      return;
    }

    final countA = int.tryParse(countAController.text) ?? 0;
    final countB = int.tryParse(countBController.text) ?? 0;
    final countC = int.tryParse(countCController.text) ?? 0;
    final countD = int.tryParse(countDController.text) ?? 0;
    final countE = int.tryParse(countEController.text) ?? 0;  // ぶどう回数

    final totalBIG = countA + countC;
    final totalREG = countB + countD;

    final shouldSave = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('記録の保存確認'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('以下の内容で保存しますか？'),
            SizedBox(height: 8),
            Text('実践G数: ${gameCount}G'),
            Text('BIG: ${totalBIG}回'),
            Text('REG: ${totalREG}回'),
            Text('ぶどう: ${countE}回'),  // 追加
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text('キャンセル'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: Text('保存'),
          ),
        ],
      ),
    );

    if (shouldSave != true) return;

    final record = PracticeRecord(
      date: DateTime.now(),
      machine: selectedMachine,
      gameCount: gameCount,
      bigProbability: totalBIG > 0 ? gameCount / totalBIG : double.infinity,
      regProbability: totalREG > 0 ? gameCount / totalREG : double.infinity,
      budouProbability: countE > 0 ? gameCount / countE : double.infinity,  // 追加
      budouCount: countE,  // 追加
    );

    await RecordService.saveRecord(record);
    Fluttertoast.showToast(msg: "記録を保存しました");
  }


  // 入力フィールドと分数表示を含むウィジェット
  Widget _buildInputFieldWithFraction(
      String label,
      TextEditingController controller,
      {String? suffix,
        String? totalValue,
        bool showFraction = false,
        bool enabled = true}) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        TextFormField(
          controller: controller,
          enabled: enabled,
          decoration: InputDecoration(
            labelText: label,
            suffix: suffix != null ? Text(suffix) : null,
            border: OutlineInputBorder(),
          ),
          keyboardType: TextInputType.number,
          validator: (value) {
            if (value == null || value.isEmpty) return null;
            if (int.tryParse(value) == null) return '数値を入力してください';
            return null;
          },
        ),
        if (showFraction && totalValue != null && totalValue.isNotEmpty)
          Padding(
            padding: EdgeInsets.only(top: 4.0),
            child: Text(
              _calculateFraction(controller.text, totalValue),
              style: TextStyle(fontSize: 12),
            ),
          ),
      ],
    );
  }

  Widget _buildCounterField(
      String label,
      TextEditingController controller,
      String? totalValue,
      ) {
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start, // 上端で揃える
        children: [
          Expanded(
            flex: 4,
            child: _buildInputFieldWithFraction(
              label,
              controller,
              suffix: '回',
              totalValue: totalValue,
              showFraction: true,
            ),
          ),
          SizedBox(width: 8),
          Container(
            width: 140,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                SizedBox(
                  height: 48, // TextFormFieldの標準的な高さに合わせる
                  child: IconButton(
                    icon: Icon(
                      Icons.remove_circle_outline,
                      size: 32,
                      color: Colors.red,
                    ),
                    padding: EdgeInsets.zero, // パディングを削除して位置を調整
                    constraints: BoxConstraints(), // デフォルトの制約を解除
                    onPressed: () {
                      int currentValue = int.tryParse(controller.text) ?? 0;
                      if (currentValue > 0) {
                        setState(() {
                          controller.text = (currentValue - 1).toString();
                        });
                        _saveData();
                      }
                    },
                  ),
                ),
                SizedBox(
                  height: 48, // TextFormFieldの標準的な高さに合わせる
                  child: IconButton(
                    icon: Icon(
                      Icons.add_circle_outline,
                      size: 32,
                      color: Colors.blue,
                    ),
                    padding: EdgeInsets.zero, // パディングを削除して位置を調整
                    constraints: BoxConstraints(), // デフォルトの制約を解除
                    onPressed: () {
                      int currentValue = int.tryParse(controller.text) ?? 0;
                      setState(() {
                        controller.text = (currentValue + 1).toString();
                      });
                      _saveData();
                    },
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return FocusScope(
      node: _focusScopeNode,
      child: Scaffold(
        body: Column(
          children: [
            // 機種選択カード - 固定表示部分
            Card(
              child: Padding(
                padding: EdgeInsets.all(16.0),
                child: Row(  // Column から Row に変更
                  children: [
                    Expanded(  // ドロップダウンを Expanded で囲む
                      child: DropdownButtonFormField<SlotMachine>(
                        isExpanded: true,
                        value: selectedMachine,
                        onChanged: (SlotMachine? newValue) {
                          setState(() {
                            selectedMachine = newValue!;
                            if (newValue == SlotMachine.gogoJuggler ||
                                newValue == SlotMachine.jugglerGirls ||
                                newValue == SlotMachine.misterJuggler ||
                                newValue == SlotMachine.ultramiracleJuggler ||
                                newValue == SlotMachine.newPulserBT
                            ) {
                              countCController.clear();
                              countDController.clear();
                            }
                            _saveData();
                          });
                        },
                        items: const [
                          DropdownMenuItem(
                            value: SlotMachine.imJuggler,
                            child: Text('アイムジャグラーEX'),
                          ),
                          DropdownMenuItem(
                            value: SlotMachine.myJuggler,
                            child: Text('マイジャグラーⅤ'),
                          ),
                          DropdownMenuItem(
                            value: SlotMachine.gogoJuggler,
                            child: Text('ゴーゴージャグラー3（実践ボーナス数は全て単独欄に入力）'),
                          ),
                          DropdownMenuItem(
                            value: SlotMachine.funkyJuggler,
                            child: Text('ファンキージャグラー2'),
                          ),
                          DropdownMenuItem(
                            value: SlotMachine.happyJuggler,
                            child: Text('ハッピージャグラーV Ⅲ'),
                          ),
                          DropdownMenuItem(
                            value: SlotMachine.jugglerGirls,
                            child: Text('ジャグラーガールズSS（実践ボーナス数は全て単独欄に入力）'),
                          ),
                          DropdownMenuItem(
                            value: SlotMachine.misterJuggler,
                            child: Text('ミスタージャグラー（実践ボーナス数は全て単独欄に入力）'),
                          ),
                          DropdownMenuItem(
                            value: SlotMachine.ultramiracleJuggler,
                            child: Text('ウルトラミラクルジャグラー（実践ボーナス数は全て単独欄に入力）'),
                          ),
                          DropdownMenuItem(
                            value: SlotMachine.newPulserBT,
                            child: Text('ニューパルサーBT（実践ボーナス数は全て単独欄に入力）'),
                          ),
                        ],
                      ),
                    ),
                    SizedBox(width: 8), // 適切な間隔を追加
                    IconButton(
                      icon: Icon(Icons.info_outline),
                      onPressed: () {
                        // 現在の確率を計算
                        Map<String, String> currentProbs = {
                          'single_big': _calculateProbString(
                              (int.tryParse(total1Controller.text) ?? 0) - (int.tryParse(total2Controller.text) ?? 0),
                              int.tryParse(countAController.text) ?? 0),
                          'single_reg': _calculateProbString(
                              (int.tryParse(total1Controller.text) ?? 0) - (int.tryParse(total2Controller.text) ?? 0),
                              int.tryParse(countBController.text) ?? 0),
                          'cherry_big': _calculateProbString(
                              (int.tryParse(total1Controller.text) ?? 0) - (int.tryParse(total2Controller.text) ?? 0),
                              int.tryParse(countCController.text) ?? 0),
                          'cherry_reg': _calculateProbString(
                              (int.tryParse(total1Controller.text) ?? 0) - (int.tryParse(total2Controller.text) ?? 0),
                              int.tryParse(countDController.text) ?? 0),
                          'budou': _calculateProbString(
                              (int.tryParse(total1Controller.text) ?? 0) - (int.tryParse(total2Controller.text) ?? 0),
                              int.tryParse(countEController.text) ?? 0),
                          'single_cherry': _calculateProbString(
                              (int.tryParse(total1Controller.text) ?? 0) - (int.tryParse(total2Controller.text) ?? 0),
                              int.tryParse(countHController.text) ?? 0),
                          'big_sum': _calculateProbString(
                              int.tryParse(total1Controller.text) ?? 0,
                              (int.tryParse(countFController.text) ?? 0) + (int.tryParse(countAController.text) ?? 0) + (int.tryParse(countCController.text) ?? 0)),
                          'reg_sum': _calculateProbString(
                              int.tryParse(total1Controller.text) ?? 0,
                              (int.tryParse(countGController.text) ?? 0) + (int.tryParse(countBController.text) ?? 0) + (int.tryParse(countDController.text) ?? 0)),
                        };

                        Navigator.push(
                          context,
                          MaterialPageRoute(
                            builder: (context) => MachineParametersScreen(
                              machine: selectedMachine,
                              currentProbabilities: currentProbs,  // 現在の確率を渡す
                            ),
                          ),
                        );
                      },
                      tooltip: 'パラメータ表示',
                    ),
                    IconButton(
                      icon: Icon(Icons.image),
                      onPressed: () {
                        Navigator.push(
                          context,
                          MaterialPageRoute(
                            builder: (context) => MachineImagesScreen(),
                          ),
                        );
                      },
                      tooltip: '機種画像一覧',
                    ),
                  ],
                ),
              ),
            ),
            // スクロール可能な残りのコンテンツ
            Expanded(
              child: SingleChildScrollView(
                controller: _scrollController,
                padding: EdgeInsets.all(16.0),
                child: Form(
                  key: _formKey,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      Card(
                        child: Padding(
                          padding: EdgeInsets.all(16.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                children: [
                                  Text('着席時データカウンター',
                                      style: Theme.of(context).textTheme.titleLarge),
                                  TextButton(
                                    onPressed: _clearCounterForm,
                                    child: Text('クリア'),
                                  ),
                                ],
                              ),
                              _buildInputField('ゲーム数', total2Controller, suffix: 'G中'),
                              Row(
                                children: [
                                  Expanded(
                                    child: _buildInputFieldWithFraction(
                                      'BIG',
                                      countFController,
                                      suffix: '回',
                                      totalValue: total2Controller.text,
                                      showFraction: true,
                                    ),
                                  ),
                                  Expanded(
                                    child: _buildInputFieldWithFraction(
                                      'REG',
                                      countGController,
                                      suffix: '回',
                                      totalValue: total2Controller.text,
                                      showFraction: true,
                                    ),
                                  ),
                                ],
                              ),
                            ],
                          ),
                        ),
                      ),
                      SizedBox(height: 16),
                      Card(
                        child: Padding(
                          padding: EdgeInsets.all(16.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                children: [
                                  Text('ボーナス・小役確率',
                                      style: Theme.of(context).textTheme.titleLarge),
                                  TextButton(
                                    onPressed: _clearBonusForm,
                                    child: Text('クリア'),
                                  ),
                                ],
                              ),
                              _buildInputField('現在の総ゲーム数', total1Controller, suffix: 'G中'),
                              SizedBox(height: 8),
                              // 4つのボーナスカウンターを縦に配置
                              _buildCounterField(
                                '単独BIG',
                                countAController,
                                ((int.tryParse(total1Controller.text) ?? 0) - (int.tryParse(total2Controller.text) ?? 0)).toString(),
                              ),
                              _buildCounterField(
                                '角チェリー+BIG',
                                countCController,
                                ((int.tryParse(total1Controller.text) ?? 0) - (int.tryParse(total2Controller.text) ?? 0)).toString(),
                              ),
                              _buildCounterField(
                                '単独REG',
                                countBController,
                                ((int.tryParse(total1Controller.text) ?? 0) - (int.tryParse(total2Controller.text) ?? 0)).toString(),
                              ),
                              _buildCounterField(
                                '角チェリー+REG',
                                countDController,
                                ((int.tryParse(total1Controller.text) ?? 0) - (int.tryParse(total2Controller.text) ?? 0)).toString(),
                              ),
                              SizedBox(height: 16),
                              Row(
                                children: [
                                  Expanded(
                                    child: _buildInputFieldWithFraction(
                                      '単独チェリー',
                                      countHController,
                                      suffix: '回',
                                      totalValue: ((int.tryParse(total1Controller.text) ?? 0) - (int.tryParse(total2Controller.text) ?? 0)).toString(),
                                      showFraction: true,
                                    ),
                                  ),
                                  SizedBox(width: 8),
                                  Expanded(
                                    child: _buildInputFieldWithFraction(
                                      'ぶどう',
                                      countEController,
                                      suffix: '回',
                                      totalValue: ((int.tryParse(total1Controller.text) ?? 0) - (int.tryParse(total2Controller.text) ?? 0)).toString(),
                                      showFraction: true,
                                    ),
                                  ),
                                ],
                              ),
                            ],
                          ),
                        ),
                      ),
                      SizedBox(height: 16),
                      Row(
                        children: [
                          Expanded(
                            child: ElevatedButton(
                              onPressed: _saveRecord,
                              child: Padding(
                                padding: EdgeInsets.all(16.0),
                                child: Text('記録を保存'),
                              ),
                            ),
                          ),
                          SizedBox(width: 8),
                          Expanded(
                            child: ElevatedButton(
                              onPressed: () {
                                Navigator.push(
                                  context,
                                  MaterialPageRoute(builder: (context) => RecordsScreen()),
                                );
                              },
                              child: Padding(
                                padding: EdgeInsets.all(16.0),
                                child: Text('記録を表示'),
                              ),
                            ),
                          ),
                        ],
                      ),
                      SizedBox(height: 16),
                      ExpansionPanelList(
                        elevation: 1,
                        expandedHeaderPadding: EdgeInsets.all(0),
                        children: [
                          ExpansionPanel(
                            headerBuilder: (context, isExpanded) {
                              return ListTile(
                                title: Text('設定配分を入力'),
                                onTap: () {
                                  setState(() {
                                    _showHaibun = !_showHaibun;
                                  });
                                },
                              );
                            },
                            body: Padding(
                              padding: EdgeInsets.all(16.0),
                              child: Column(
                                children: [
                                  for (int i = 0; i < 6; i += 2)
                                    Row(
                                      children: [
                                        Expanded(
                                          child: _buildInputField(
                                              '設定${i + 1}',
                                              haibunControllers[i],
                                              suffix: '台'
                                          ),
                                        ),
                                        SizedBox(width: 8),
                                        Expanded(
                                          child: _buildInputField(
                                              '設定${i + 2}',
                                              haibunControllers[i + 1],
                                              suffix: '台'
                                          ),
                                        ),
                                      ],
                                    ),
                                  SizedBox(height: 16),
                                  Row(
                                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                                    children: [
                                      ElevatedButton(
                                        onPressed: () {
                                          setState(() {
                                            for (var controller in haibunControllers) {
                                              controller.text = '1';
                                            }
                                          });
                                          _saveData();
                                        },
                                        child: Text('均等'),
                                      ),
                                      ElevatedButton(
                                        onPressed: () {
                                          setState(() {
                                            final values = [15, 50, 20, 13, 2, 1];
                                            for (int i = 0; i < haibunControllers.length; i++) {
                                              haibunControllers[i].text = values[i].toString();
                                            }
                                          });
                                          _saveData();
                                        },
                                        child: Text('通常'),
                                      ),
                                      ElevatedButton(
                                        onPressed: () {
                                          setState(() {
                                            final values = [15, 45, 25, 15, 9, 2];
                                            for (int i = 0; i < haibunControllers.length; i++) {
                                              haibunControllers[i].text = values[i].toString();
                                            }
                                          });
                                          _saveData();
                                        },
                                        child: Text('特日'),
                                      ),
                                    ],
                                  ),
                                ],
                              ),
                            ),
                            isExpanded: _showHaibun,
                          ),
                        ],
                        expansionCallback: (panelIndex, isExpanded) {
                          setState(() {
                            _showHaibun = !_showHaibun;
                          });
                        },
                      ),
                      SizedBox(height: 16),
                      ElevatedButton(
                        onPressed: _calculate,
                        child: Padding(
                          padding: EdgeInsets.all(16.0),
                          child: Text('設定判別する'),
                        ),
                      ),
                      if (result != null) ...[
                        SizedBox(height: 16),
                        Card(
                          child: Padding(
                            padding: EdgeInsets.all(16.0),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text('設定期待度',
                                    style: Theme.of(context).textTheme.titleLarge),
                                ...List.generate(6, (index) {
                                  return Column(
                                    children: [
                                      SizedBox(height: 8),
                                      Text('設定${index + 1}: ${result!.probabilities[index]}%'),
                                      LinearProgressIndicator(
                                        value: (result!.probabilities[index] / 100).isNaN ?
                                        0.0 :
                                        (result!.probabilities[index] / 100).clamp(0.0, 1.0),
                                      ),
                                    ],
                                  );
                                }),
                                SizedBox(height: 16),
                                Text('各平均期待値',
                                    style: Theme.of(context).textTheme.titleMedium),
                                ListTile(
                                  title: Text('平均設定'),
                                  trailing: Text('${result!.averageSettings}'),
                                ),
                                ListTile(
                                  title: Text('平均PAYOUT'),
                                  trailing: Text('${result!.averagePayout}%'),
                                ),
                                ListTile(
                                  title: Text('平均時給(800G/時)'),
                                  trailing: Text('${result!.averageWage}円(${result!.averageWage/20}枚)'),
                                ),
                              ],
                            ),
                          ),
                        ),
                      ],
                    ],
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

### services\record_service.dart

```
// lib/services/record_service.dart

import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/practice_record.dart';
import '../services/slot_calculator.dart';

class RecordService {
  static const String _recordsKey = 'practice_records';

  // データを移行するメソッド
  static Future<void> migrateData() async {
    final prefs = await SharedPreferences.getInstance();
    List<String> records = prefs.getStringList(_recordsKey) ?? [];

    bool needsMigration = false;
    List<String> migratedRecords = [];

    for (var record in records) {
      try {
        final data = jsonDecode(record);
        if (!data.containsKey('budouCount')) {
          needsMigration = true;
          // 古いデータに新しいフィールドを追加
          data['budouCount'] = 0;
          data['budouProbability'] = 'Infinity';
        }
        migratedRecords.add(jsonEncode(data));
      } catch (e) {
        print('Error migrating record: $e');
        needsMigration = true;
      }
    }

    if (needsMigration) {
      await prefs.setStringList(_recordsKey, migratedRecords);
    }
  }

  // 全記録を取得する前にデータ移行を実行
  static Future<List<PracticeRecord>> getAllRecords() async {
    await migrateData(); // データ移行を実行

    final prefs = await SharedPreferences.getInstance();
    List<String> records = prefs.getStringList(_recordsKey) ?? [];
    return records
        .map((str) => PracticeRecord.fromJson(jsonDecode(str)))
        .toList();
  }

  // 記録を保存
  static Future<void> saveRecord(PracticeRecord record) async {
    final prefs = await SharedPreferences.getInstance();
    List<String> records = prefs.getStringList(_recordsKey) ?? [];
    records.add(jsonEncode(record.toJson()));
    await prefs.setStringList(_recordsKey, records);
  }

  //差枚を入力して保存
  static Future<void> updateCoinDifference(DateTime date, SlotMachine machine, int coinDifference) async {
    final prefs = await SharedPreferences.getInstance();
    List<String> records = prefs.getStringList(_recordsKey) ?? [];

    final updatedRecords = records.map((record) {
      final data = jsonDecode(record);
      if (data['date'] == date.toIso8601String() && data['machine'] == machine.toString()) {
        data['coinDifference'] = coinDifference;
      }
      return jsonEncode(data);
    }).toList();

    await prefs.setStringList(_recordsKey, updatedRecords);
  }

  static Future<Map<SlotMachine, Map<String, dynamic>>> getMachineSummaries() async {
    final records = await getAllRecords();
    Map<SlotMachine, Map<String, dynamic>> summaries = {};

    for (var record in records) {
      if (!summaries.containsKey(record.machine)) {
        summaries[record.machine] = {
          'totalGames': 0,
          'totalBigCount': 0,
          'totalRegCount': 0,
          'totalBudouCount': 0,
          'totalCoinDifference': 0,  // 追加
        };
      }

      var summary = summaries[record.machine]!;
      summary['totalGames'] += record.gameCount;

      if (!record.bigProbability.isInfinite && !record.bigProbability.isNaN) {
        summary['totalBigCount'] += (record.gameCount / record.bigProbability).round();
      }
      if (!record.regProbability.isInfinite && !record.regProbability.isNaN) {
        summary['totalRegCount'] += (record.gameCount / record.regProbability).round();
      }
      summary['totalBudouCount'] += record.budouCount;
      if (record.coinDifference != null) {
        summary['totalCoinDifference'] += record.coinDifference!;
      }
    }

    summaries.forEach((machine, data) {
      if (data['totalGames'] > 0) {
        if (data['totalBigCount'] > 0) {
          data['avgBigProbability'] = data['totalGames'] / data['totalBigCount'];
        } else {
          data['avgBigProbability'] = double.infinity;
        }

        if (data['totalRegCount'] > 0) {
          data['avgRegProbability'] = data['totalGames'] / data['totalRegCount'];
        } else {
          data['avgRegProbability'] = double.infinity;
        }

        // ぶどうの確率を計算 (追加)
        if (data['totalBudouCount'] > 0) {
          data['avgBudouProbability'] = data['totalGames'] / data['totalBudouCount'];
        } else {
          data['avgBudouProbability'] = double.infinity;
        }

        data['totalBonusCount'] = data['totalBigCount'] + data['totalRegCount'];
        if (data['totalBonusCount'] > 0) {
          data['avgTotalProbability'] = data['totalGames'] / data['totalBonusCount'];
        } else {
          data['avgTotalProbability'] = double.infinity;
        }
      }
    });

    return summaries;
  }

  // 特定の記録を削除
  static Future<void> deleteRecord(DateTime date, SlotMachine machine) async {
    final prefs = await SharedPreferences.getInstance();
    List<String> records = prefs.getStringList(_recordsKey) ?? [];

    records.removeWhere((record) {
      final recordData = PracticeRecord.fromJson(jsonDecode(record));
      return recordData.date.isAtSameMomentAs(date) &&
          recordData.machine == machine;
    });

    await prefs.setStringList(_recordsKey, records);
  }

  // 複数の記録を削除
  static Future<void> deleteRecords(List<PracticeRecord> recordsToDelete) async {
    final prefs = await SharedPreferences.getInstance();
    List<String> records = prefs.getStringList(_recordsKey) ?? [];

    records.removeWhere((record) {
      final recordData = PracticeRecord.fromJson(jsonDecode(record));
      return recordsToDelete.any((r) =>
      r.date.isAtSameMomentAs(recordData.date) &&
          r.machine == recordData.machine
      );
    });

    await prefs.setStringList(_recordsKey, records);
  }

  static String getProbabilityFraction(double probability) {
    if (probability.isInfinite || probability.isNaN) return "－";
    double roundedProbability = double.parse(probability.toStringAsFixed(2));
    return "1/$roundedProbability";
  }
}
```

### services\slot_calculator.dart

```
// lib/services/slot_calculator.dart

import 'dart:math';
import 'package:flutter/material.dart';
import 'package:fluttertoast/fluttertoast.dart';

import '../models/calculation_result.dart';

enum SlotMachine {
  imJuggler,
  myJuggler,
  gogoJuggler,
  funkyJuggler,
  happyJuggler,
  jugglerGirls,
  misterJuggler,
  ultramiracleJuggler,
  newPulserBT
}

class SlotCalculator {
  static const Map<SlotMachine, Map<String, List<double>>> machineParameters = {
    SlotMachine.imJuggler: {
      'payout': [98.4, 99.4, 101.1, 102.9, 105.3, 107.5],
      'single_big': [387.8, 381.0, 381.0, 370.26, 370.26, 362.08],
      'single_reg': [636.27, 569.89, 471.48, 445.8, 362.08, 362.08],
      'cherry_big': [923.04, 923.04, 923.04, 862.3, 862.3, 862.3],
      'cherry_reg': [1424.7, 1337.47, 1110.78, 1074.36, 862.3, 862.3],
      'budou': [6.02, 6.02, 6.02, 6.02, 6.02, 5.848],
      'single_cherry': [35.62, 35.62, 35.62, 35.62, 35.62, 35.62],
      'big_sum': [273.1, 269.7, 269.7, 259.0, 259.0, 255.0],
      'reg_sum': [439.8, 399.6, 331.0, 315.1, 255.0, 255.0],
    },
    SlotMachine.myJuggler: {
      'payout': [98.3, 99.4, 101.6, 104.7, 107.5, 112.0],
      'single_big': [420.1, 414.8, 404.5, 376.6, 348.6, 341.3],
      'single_reg': [655.36, 595.8, 496.5, 404.5, 390.1, 327.7],
      'cherry_big': [1365.3, 1365.3, 1365.3, 1365.3, 1337.5, 1129.9],
      'cherry_reg': [1092.267, 1092.267, 1040.25, 1024.0, 862.3, 762.047],
      'budou': [5.98, 5.88, 5.84, 5.81, 5.76, 5.65],
      'single_cherry': [35.85, 35.85, 35.85, 34.66, 33.35, 33.03],
      'big_sum': [273.1, 270.8, 266.4, 254.0, 240.1, 229.1],
      'reg_sum': [409.6, 385.5, 336.1, 290.0, 268.6, 229.1],
    },
    SlotMachine.gogoJuggler: {
      'payout': [98.7, 99.75, 101.09, 103.2, 105.6, 108.40],
      'single_big': [259.0, 258.0, 257.0, 254.0, 247.3, 234.9],
      'single_reg': [354.2, 332.7, 306.2, 268.6, 247.3, 234.9],
      'cherry_big': [999,999,999,999,999,999],
      'cherry_reg': [999,999,999,999,999,999],
      'budou': [6.25, 6.2, 6.15, 6.07, 6.00, 5.92],
      'single_cherry': [33.4, 33.3, 33.2, 33.1, 32.9, 32.8],
      'big_sum': [259.0, 258.0, 257.0, 254.0, 247.3, 234.9],
      'reg_sum': [354.2, 332.7, 306.2, 268.6, 247.3, 234.9],
    },
    SlotMachine.funkyJuggler: {
      'payout': [98.2, 99.7, 101.35, 103.7, 106.4, 111.75],
      'single_big': [358.12, 352.344, 344.926, 330.99, 327.68, 295.207],
      'single_reg': [648.871, 569.878, 500.275, 445.823, 409.6, 344.926],
      'cherry_big': [1040.254, 1024.0, 992.97, 978.149, 923.042, 910.222],
      'cherry_reg': [1489.455, 1394.383, 1285.02, 1236.528, 1213.63, 1057.032],
      'budou': [5.94, 5.9298, 5.8798, 5.8301, 5.80, 5.77],
      'single_cherry': [35.62, 35.62, 35.62, 35.62, 35.62, 35.62],
      'big_sum': [266.4, 259.0, 256.0, 249.2, 240.1, 219.9],
      'reg_sum': [439.8, 407.1, 366.1, 322.8, 299.3, 262.1],
    },
    SlotMachine.happyJuggler: {
      'payout': [98.48, 99.63, 101.45, 105.6, 108.0, 110.85],
      'single_big': [358.12, 354.249, 348.596, 341.333, 322.837, 296.543],
      'single_reg': [682.667, 612.486, 574.877, 496.485, 455.111, 439.839],
      'cherry_big': [1149.754, 1149.754, 1149.754, 936.229, 923.042, 949.797],
      'cherry_reg': [936.229, 885.622, 789.59, 762.047, 682.667, 612.486],
      'budou': [6.04, 6.01, 5.98, 5.86, 5.84, 5.82],
      'single_cherry': [56.55, 56.55, 56.55, 56.55, 56.55, 56.55],
      'big_sum': [273.1, 270.8, 263.2, 254.0, 239.2, 226.0],
      'reg_sum': [397.2, 362.1, 332.7, 300.6, 273.1, 256.0],
    },
    SlotMachine.jugglerGirls: {
      'payout': [98.45, 99.41, 101.5, 103.85, 105.72, 109.23],
      'single_big': [273.1, 270.8, 260.06, 250.14, 243.63, 225.99],
      'single_reg': [381.02, 350.46, 316.6, 281.27, 270.81, 252.06],
      'cherry_big': [999,999,999,999,999,999],
      'cherry_reg': [999,999,999,999,999,999],
      'budou': [6.01, 6.01, 6.01, 6.01, 5.92, 5.89],
      'single_cherry': [33.61, 33.51, 33.3, 33.2, 33.1, 32.9],
      'big_sum': [273.1, 270.8, 260.06, 250.14, 243.63, 225.99],
      'reg_sum': [381.02, 350.46, 316.6, 281.27, 270.81, 252.06],
    },
    SlotMachine.misterJuggler: {
      'payout': [99.3, 100.32, 102.17, 105.04, 107.89, 109.69],
      'single_big': [268.59, 267.49, 260.06, 249.19, 240.94, 237.45],
      'single_reg': [374.49, 354.25, 330.99, 291.27, 257.00, 237.45],
      'cherry_big': [999,999,999,999,999,999],
      'cherry_reg': [999,999,999,999,999,999],
      'budou': [6.207, 6.154, 6.111, 6.076, 6.043, 6.005],
      'single_cherry': [33.61, 33.51, 33.3, 33.2, 33.1, 32.9],
      'big_sum': [268.59, 267.49, 260.06, 249.19, 240.94, 237.45],
      'reg_sum': [374.49, 354.25, 330.99, 291.27, 257.00, 237.45],
    },
    SlotMachine.ultramiracleJuggler: {
      'payout': [98.15, 99.4, 101.3, 103.75, 106.0, 109.6],
      'single_big': [267.5, 261.1, 256.0, 242.7, 233.2, 216.3],
      'single_reg': [425.6, 402.1, 350.5, 322.8, 297.9, 277.7],
      'cherry_big': [999,999,999,999,999,999],
      'cherry_reg': [999,999,999,999,999,999],
      'budou': [5.940, 5.938, 5.936, 5.934, 5.933, 5.929],
      'single_cherry': [35.54, 35.54, 34.86, 34.79, 34.13, 33.44],
      'big_sum': [267.5, 261.1, 260.06, 242.7, 233.2, 216.3],
      'reg_sum': [425.6, 402.1, 350.5, 322.8, 297.9, 277.7],
    },
    SlotMachine.newPulserBT: {
      'payout': [100, 101.5, 101.5, 101.5, 104.5, 108.3],
      'single_big': [366.1, 346.8, 346.8, 346.8, 332.7, 312.1],
      'single_reg': [366.1, 346.8, 346.8, 346.8, 332.7, 312.1],
      'cherry_big': [999,999,999,999,999,999],
      'cherry_reg': [999,999,999,999,999,999],
      'budou': [999,999,999,999,999,999],
      'single_cherry': [999,999,999,999,999,999],
      'big_sum': [366.1, 346.8, 346.8, 346.8, 332.7, 312.1],
      'reg_sum': [366.1, 346.8, 346.8, 346.8, 332.7, 312.1],
    },
  };

  static CalculationResult calculate({
    required String total1,
    required String countA,
    required String countB,
    required String countC,
    required String countD,
    required String countE,
    required String total2,
    required String countF,
    required String countG,
    required String countH,
    required List<String> haibun,
    required SlotMachine machine,
  }) {
    // 入力値の変換とバリデーション
    int countAValue = int.tryParse(countA) ?? 0;
    int countBValue = int.tryParse(countB) ?? 0;
    int countCValue = int.tryParse(countC) ?? 0;
    int countDValue = int.tryParse(countD) ?? 0;
    int countEValue = int.tryParse(countE) ?? 0;
    int total2Value = int.tryParse(total2) ?? 0;
    int countFValue = int.tryParse(countF) ?? 0;
    int countGValue = int.tryParse(countG) ?? 0;
    int countHValue = int.tryParse(countH) ?? 0;

    int total1Value = (int.tryParse(total1) ?? 0) - total2Value;

    // 入力値の検証
    bool hasValidData = false;
    if (total1Value > 0) {
      if (countAValue > 0 || countBValue > 0 || countCValue > 0 ||
          countDValue > 0 || countEValue > 0 || countHValue > 0) {
        hasValidData = true;
      }
    }
    if (total2Value > 0) {
      if (countFValue > 0 || countGValue > 0) {
        hasValidData = true;
      }
    }

    if (!hasValidData) {
      // デフォルト値を返す
      return CalculationResult(
        probabilities: List.filled(6, 16.67),
        averageSettings: 3.5,
        averagePayout: machineParameters[machine]!['payout']!
            .reduce((a, b) => a + b) / 6,
        averageWage: 0,
        probStrings: List.filled(7, "－"),
      );
    }

    List<int> haibunValues = haibun
        .map((e) => int.tryParse(e) ?? 1)
        .toList();

    // 機種のパラメータを取得
    final params = machineParameters[machine]!;

    // 確率計算用の配列
    List<List<double>> probs = List.generate(8, (_) => List.filled(6, 1.0));

    // 単独BIG確率計算
    if (total1Value > 0 && countAValue >= 0) {
      _calculateProbability(
          total1Value,
          countAValue,
          params['single_big']!,
          probs[0]
      );
    }

    // 単独REG確率計算
    if (total1Value > 0 && countBValue >= 0) {
      _calculateProbability(
          total1Value - countAValue,
          countBValue,
          params['single_reg']!,
          probs[1]
      );
    }

    // 角チェリー+BIG確率計算
    if (total1Value > 0 && countCValue >= 0) {
      _calculateProbability(
          total1Value - countAValue - countBValue,
          countCValue,
          params['cherry_big']!,
          probs[2]
      );
    }

    // 角チェリー+REG確率計算
    if (total1Value > 0 && countDValue >= 0) {
      _calculateProbability(
          total1Value - countAValue - countBValue - countCValue,
          countDValue,
          params['cherry_reg']!,
          probs[3]
      );
    }

    // ぶどう確率計算
    if (total1Value > 0 && countEValue > 0) {
      _calculateProbability(
          total1Value - countAValue - countBValue - countCValue - countDValue,
          countEValue,
          params['budou']!,
          probs[4]
      );
    }

    // データカウンターBIG確率計算
    if (total2Value > 0 && countFValue > 0) {
      _calculateProbability(
          total2Value,
          countFValue,
          params['big_sum']!,
          probs[5]
      );
    }

    // データカウンターREG確率計算
    if (total2Value > 0 && countGValue > 0) {
      _calculateProbability(
          total2Value - countFValue,
          countGValue,
          params['reg_sum']!,
          probs[6]
      );
    }

    // 単独チェリー確率計算
    if (total1Value > 0 && countHValue > 0) {
      _calculateProbability(
          total1Value - countAValue - countBValue - countCValue - countDValue - countEValue,
          countHValue,
          params['single_cherry']!,
          probs[7]
      );
    }

    // 設定配分の計算
    double haibunSum = haibunValues.reduce((a, b) => a + b).toDouble();
    List<double> haibunRatios = haibunValues.map((v) => v / haibunSum).toList();

    // 総合確率の計算
    List<double> finalProbs = List.filled(6, 0.0);
    for (int i = 0; i < 6; i++) {
      double settingProb = haibunRatios[i];
      for (int j = 0; j < probs.length; j++) {
        settingProb *= probs[j][i];
      }
      finalProbs[i] = settingProb;
    }

    // 確率の正規化
    double totalProb = finalProbs.reduce((a, b) => a + b);
    List<double> probabilities = finalProbs
        .map((p) => double.parse((p / totalProb * 100).toStringAsFixed(2)))
        .toList();

    // 出現確率の文字列計算
    List<String> probStrings = [
      _calculateProbString(total1Value, countAValue),
      _calculateProbString(total1Value, countBValue),
      _calculateProbString(total1Value, countCValue),
      _calculateProbString(total1Value, countDValue),
      _calculateProbString(total1Value, countEValue),
      _calculateProbString(total2Value, countFValue),
      _calculateProbString(total2Value, countGValue),
      _calculateProbString(total1Value, countHValue),
    ];

    // 平均値の計算
    double averageSettings = _calculateAverageSettings(probabilities);
    double averagePayout = _calculateAveragePayout(probabilities, params['payout']!);
    double averageWage = _calculateAverageWage(probabilities, params['payout']!);

    return CalculationResult(
      probabilities: probabilities,
      averageSettings: averageSettings,
      averagePayout: averagePayout,
      averageWage: averageWage,
      probStrings: probStrings,
    );
  }

  static void _calculateProbability(
      int total,
      int count,
      List<double> settings,
      List<double> results
      ) {
    try {
      if (total <= 0) return;

      List<double> lcomb = List<double>.filled(total + 1, 0);
      double lsum = 0;
      for (int idx = 2; idx <= total; idx++) {
        lsum += log(idx);
        lcomb[idx] = lsum;
      }

      int remaining = total - count;
      double prob = lcomb[total] - lcomb[count] - lcomb[remaining];

      for (int i = 0; i < 6; i++) {
        double lk = log(1/settings[i]);
        double lm = log(1 - 1/settings[i]);
        if (count == 0) {
          // カウントが0の場合は、事象が発生しなかった確率を計算
          results[i] = exp(total * lm);
        } else {
          // 通常の確率計算
          results[i] = exp(prob + count * lk + remaining * lm);
        }
      }
    } catch (e) {
      Fluttertoast.showToast(
          msg: "計算中にエラーが発生しました: $e",
          toastLength: Toast.LENGTH_LONG,
          gravity: ToastGravity.BOTTOM,
          timeInSecForIosWeb: 4,
          backgroundColor: Colors.red,
          textColor: Colors.white,
          fontSize: 16.0
      );
    }
  }

  static String _calculateProbString(int total, int count) {
    if (total == 0 || count == 0) {
      return "－";
    }
    return "1/${(total/count).round()}";
  }

  static double _calculateAverageSettings(List<double> probabilities) {
    double sum = 0;
    for (int i = 0; i < probabilities.length; i++) {
      sum += (i + 1) * (probabilities[i] / 100);
    }
    return double.parse(sum.toStringAsFixed(2));
  }

  static double _calculateAveragePayout(List<double> probabilities, List<double> payouts) {
    double sum = 0;
    for (int i = 0; i < probabilities.length; i++) {
      sum += payouts[i] * (probabilities[i] / 100);
    }
    return double.parse(sum.toStringAsFixed(2));
  }

  static double _calculateAverageWage(List<double> probabilities, List<double> payouts) {
    double sum = 0;
    for (int i = 0; i < probabilities.length; i++) {
      sum += 2400 * (payouts[i] - 100) / 100 * 20 * (probabilities[i] / 100);
    }
    return double.parse(sum.toStringAsFixed(0));
  }
}
```

